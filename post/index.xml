<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on Locory&#39;s Blog</title>
    <link>https://luolr.github.io/post/index.xml</link>
    <description>Recent content in Posts on Locory&#39;s Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>All rights reserved - 2017</copyright>
    <lastBuildDate>Sat, 03 Jun 2017 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://luolr.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>正则那些事</title>
      <link>https://luolr.github.io/post/regex/</link>
      <pubDate>Sat, 03 Jun 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luolr.github.io/post/regex/</guid>
      <description>&lt;p&gt;本文的目标，就是让你能够了解正则是什么，怎么用，并且学的轻松，用的快乐：）
&lt;/p&gt;

&lt;h3 id=&#34;前言&#34;&gt;前言&lt;/h3&gt;

&lt;p&gt;想必有不少人跟我一样，身为一名开发人员，却对正则这东西知之甚少，甚至于完全不会用。我很长一段时间也是，工作也有段时间了，却只会写一些很简单的正则匹配，想写个电话号码匹配，我都要抓耳挠腮半天最后百度，甚是惭愧。
于是乎，我痛下决心，我要弄懂它。不过学习的过程总是痛苦的，为了监督自己，也算是做个总结，我觉得边学边写是个好主意。毕竟，输入的最好方式是输出。&lt;/p&gt;

&lt;h3 id=&#34;那么-什么是正则呢&#34;&gt;那么，什么是正则呢？&lt;/h3&gt;

&lt;p&gt;正则表达式描述了一种字符串匹配的模式（pattern），可以用来检查一个串是否含有某种子串、将匹配的子串替换或者从某个串中取出符合某个条件的子串等。&lt;/p&gt;

&lt;p&gt;简单来说，就是用于一种用于描述匹配规则的工具，通常用于检索、替换符合某些规则的文本，在很多场合都用得到，就例如前文提到的电话号码匹配。你实际生活中肯定也用过不少，比如在文件夹检索文件，在页面中查找关键字等，这些都跟正则有关。&lt;/p&gt;

&lt;p&gt;那么假如，你写了一个正则表达式，要如何验证它的正确性呢？最常用的方法有两种：&lt;code&gt;patt.test(str)&lt;/code&gt;和&lt;code&gt;str.match(patt)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;请打开浏览器的控制台，将你的的正则表达式（例如&lt;code&gt;/\w{2,10}/&lt;/code&gt;）输入到控制台中，然后输入&lt;code&gt;.test(str)&lt;/code&gt;并回车，str就是你要测试的字符串，正确的话控制台就会输出true，反之为false。当然你也可以使用&lt;code&gt;str.match(patt)&lt;/code&gt;的方式。&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;step1-初窥门径&#34;&gt;step1：初窥门径&lt;/h3&gt;

&lt;p&gt;本文为了方便理解，会采用先抛出一个例子，再补充相关知识，最后公布答案的方式。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题1：假如你要在一篇文章中找出&lt;code&gt;he&lt;/code&gt;的字符串，那么正则怎么写呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;这就是最简单的正则表达式，你只需要使用正则表达式&lt;code&gt;he&lt;/code&gt;。这样就能找到那些包含he的字符串，不过，很多单词也包含了he这个字符串，例如hello、heart等。如果直接使用&lt;code&gt;he&lt;/code&gt;来检索的话，这些单词也会被找出，如果想精准的找出he这个单词的话，那么就该&lt;code&gt;\b&lt;/code&gt;出场了。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;\b&lt;/code&gt;是正则表达式规定的一个特殊代码，也叫元字符，代表着单词的开头或结尾，也就是单词的分界处。虽然通常英文的单词是由空格，标点符号或者换行来分隔的，但是&lt;code&gt;\b&lt;/code&gt;并不匹配这些单词分隔字符中的任何一个，它只匹配一个位置。&lt;/p&gt;

&lt;p&gt;所以这道题的答案是：&lt;code&gt;\bhe\b&lt;/code&gt; ，同理，假如你要查找的是&lt;code&gt;hello world&lt;/code&gt;，那么就应该用&lt;code&gt;\bhello\bworld\b&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;元字符&#34;&gt;元字符&lt;/h3&gt;

&lt;p&gt;现在，你已经认识了一个元字符，其实正则表达式里还有更多的元字符，将这些组合在一起使用，可以构造出功能更强大、更复杂的正则表达式。那么，先来认识一下它们：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;元字符&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;.&lt;/td&gt;
&lt;td&gt;匹配除换行符以外的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\w&lt;/td&gt;
&lt;td&gt;匹配字母或数字或下划线或汉字&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\s&lt;/td&gt;
&lt;td&gt;匹配任意的空白符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\d&lt;/td&gt;
&lt;td&gt;匹配数字0-9&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\b&lt;/td&gt;
&lt;td&gt;匹配单词的开始或结束&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\W&lt;/td&gt;
&lt;td&gt;匹配任意不是字母或数字或下划线或汉字的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\S&lt;/td&gt;
&lt;td&gt;匹配任意不是空白符的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\D&lt;/td&gt;
&lt;td&gt;匹配任意非数字的字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;\B&lt;/td&gt;
&lt;td&gt;匹配不是单词开头或结尾的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;[^x]&lt;/td&gt;
&lt;td&gt;匹配除了x以外的任意字符&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;^&lt;/td&gt;
&lt;td&gt;匹配字符串的开始&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;$&lt;/td&gt;
&lt;td&gt;匹配字符的的结束&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;其中&lt;code&gt;s&lt;/code&gt;用于匹配任意的空白符，包括空格、制表符（Tab）、换行符、中文全角空格等，&lt;code&gt;[^x]&lt;/code&gt;表示不匹配^后面跟着的字符串，&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;则表示匹配字符的的开始和结束，用在正则表达式的开头和结尾，这两个用来用户验证输入的内容时非常合适。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题2：如何匹配一个类似&lt;code&gt;4 G&lt;/code&gt;的由数字、空格、字母组成的字符串呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;很简单，我们只需要将我们学到的元字符组合起来就行了，答案是：&lt;code&gt;^\d\s\w$&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;限定符&#34;&gt;限定符&lt;/h3&gt;

&lt;p&gt;你现在认识了不少有用的元字符，这些元字符在实际使用的时候，往往不是单个数字或者字母等，可能会重复很多次，这时要怎么办呢？&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题3：假如要匹配一个类似于&lt;code&gt;Leonardo.DiCaprio&lt;/code&gt;或者&lt;code&gt;Hugh.Jackman&lt;/code&gt;的由两个长度为4到8位的单词以及一个&lt;code&gt;.&lt;/code&gt;组成的名字，正则应该怎么写呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;在这里，我们就要引入一个新的概念，用来表示重复次数的限定符。下面是正则表达式中所有的限定符：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;代码/语法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;*&lt;/td&gt;
&lt;td&gt;重复零次或更多次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;+&lt;/td&gt;
&lt;td&gt;重复一次或更多次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;？&lt;/td&gt;
&lt;td&gt;重复零次或一次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n}&lt;/td&gt;
&lt;td&gt;重复n次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,}&lt;/td&gt;
&lt;td&gt;重复n次或更多次&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;{n,m}&lt;/td&gt;
&lt;td&gt;重复n到m次&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;那么就很简单了，长度4到8位的单词可以用&lt;code&gt;\w{4,8}&lt;/code&gt;来表示，不过&lt;code&gt;.&lt;/code&gt;呢，直接使用.是肯定不行的，正则会将它解释成匹配除换行符以外的任意字符， 这时你就需要使用\来取消这些字符的特殊意义。
例如使用&lt;code&gt;\.&lt;/code&gt;和&lt;code&gt;\*&lt;/code&gt;来匹配&lt;code&gt;.&lt;/code&gt;和&lt;code&gt;*&lt;/code&gt;，当然要查找&lt;code&gt;\&lt;/code&gt;本身，你可以使用&lt;code&gt;\\&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么，答案就是&lt;code&gt;^\w{4,8}\.\w{4,8}$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;step2-小试牛刀&#34;&gt;step2：小试牛刀&lt;/h3&gt;

&lt;p&gt;在认识了这么多元字符和限定符之后，或许我们可以来挑战一下实际会用的那些正则了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题4：如何匹配一个手机号码呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;要解决这个问题，我们先要理清楚手机号码由哪几部分组成，手机号首先是由限定的3位数字（号码段）和任意8位数字组成的11位数字，号码段根据运营商分为以下几种（统计于2017.06）：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;运&amp;nbsp;营&amp;nbsp;商&lt;/th&gt;
&lt;th&gt;号码段&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;移动&lt;/td&gt;
&lt;td&gt;134、135、136、137、138、139、147、150、151、152、157、158、159、170、178、182、183、187、188&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;联通&lt;/td&gt;
&lt;td&gt;130、131、132、145、155、156、170、175、176、185、186&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;电信&lt;/td&gt;
&lt;td&gt;133、149、153、170、173、177、180、181、189&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;由于号码段的存在，我们又得引入一个新的概念——分枝条件，即&lt;code&gt;x|y&lt;/code&gt;，它主要用来匹配条件x或y。例如&lt;code&gt;[s|f]ox&lt;/code&gt;可以匹配sox或fox。&lt;/p&gt;

&lt;p&gt;然后我们在结合之前的知识，那么号码段部分就可以由&lt;code&gt;(13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(17([0,3,5-8]))|(18([0-3]|[5-9]))&lt;/code&gt;来表示，看起来是不是很复杂，不过仔细看的话，其实只是简单的排列组合罢了。&lt;/p&gt;

&lt;p&gt;那么答案也就呼之欲出了，剩下的只需要将号码段和任意的8位数字进行组合就行了，即&lt;code&gt;^((13[0-9])|(14[5|7])|(15([0-3]|[5-9]))|(17([0,3,5-8]))|(18([0-3]|[5-9])))\d{8}$&lt;/code&gt;，注意不要少了&lt;code&gt;^&lt;/code&gt;和&lt;code&gt;$&lt;/code&gt;喔。&lt;/p&gt;

&lt;p&gt;怎么样，现在是不是很有成就感呢，为了熟练使用，我们再做一个题。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题5：如何匹配一个可能是XXX-XXXXXXX、XXX-XXXXXXXX、XXXX-XXXXXXX、XXXX-XXXXXXXX、XXXXXXX和XXXXXXXX格式的固定电话呢？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;我们将问题整理一下，座机可能有区号（3-4位），也可能没有区号，号码也可能是7位或者8位，那么总共有3+7、3+8、4+7、4+8、7位、8位的6种情况。&lt;/p&gt;

&lt;p&gt;首先，我们可以使用&lt;code&gt;\d{3,4}&lt;/code&gt;来表示3-4位的区号，然后有区号后面可以会跟一个&lt;code&gt;-&lt;/code&gt;，当然也可以没有区号，那么就变成&lt;code&gt;(\d{3,4}-)?&lt;/code&gt;，7-8位的号码很好表示，即&lt;code&gt;\d{7,8}&lt;/code&gt;，再将两者进行组合，答案就出来了：&lt;code&gt;^(\d{3,4}-)?\d{7,8}$&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;step3-炉火纯青&#34;&gt;step3：炉火纯青&lt;/h3&gt;

&lt;p&gt;恭喜你学到了这里，想必你对正则表达式已经有了一定的了解，不过不要放松，真正困难的还在后面。&lt;/p&gt;

&lt;p&gt;前面我们已经提到了如何重复单个字符（直接在字符后面加上限定符就行了），但如果想要重复多个字符又该怎么办？你可以用小括号来指定&lt;strong&gt;子表达式&lt;/strong&gt;(也叫做分组)，然后你就可以指定这个子表达式的重复次数了，当然你也可以对子表达式进行其它一些操作。&lt;/p&gt;

&lt;p&gt;那么如何创建一个子表达式呢，默认情况下，一对括号之内的字符就是一个子表达式，它会自动拥有一个组号，规则是：从左向右，以分组的左括号为标志，第一个出现的分组的组号为1，第二个为2，以此类推。然后，我们就可以开始学习关于分组的语法了。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;后向引用&lt;/em&gt;&lt;/strong&gt;用于重复搜索前面某个分组匹配的文本。例如，\1代表分组1匹配的文本。难以理解？请看示例：&lt;code&gt;\b(\w+)\b\s+\1\b&lt;/code&gt;可以用来匹配重复的单词，像go go, 或者di di。&lt;/p&gt;

&lt;p&gt;不过你也可以自己指定子表达式的组名。要指定一个子表达式的组名，可以使用这样的语法：&lt;code&gt;(?&amp;lt;name&amp;gt;exp)&lt;/code&gt;或者&lt;code&gt;(?&#39;name&#39;exp)&lt;/code&gt;，这样exp的组名就被指定为name了。在引用这个分组时，需要使用&lt;code&gt;\k&amp;lt;name&amp;gt;&lt;/code&gt;，那么上一个例子也可以写作&lt;code&gt;\b(?&amp;lt;Word&amp;gt;\w+)\b\s+\k&amp;lt;Word&amp;gt;\b&lt;/code&gt;。当然，关于分组还有很多特定用途的语法。下面列出了最常用的一些：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;分类&lt;/th&gt;
&lt;th&gt;代码/语法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;捕获&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配exp,并捕获文本到自动命名的组里&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;捕获&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;name&amp;gt;exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配exp,并命名为name，也可写作&lt;code&gt;(?&#39;name&#39;exp)&lt;/code&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;捕获&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?:exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配exp,不捕获匹配的文本，也不给此分组分配组号&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;零宽断言&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?=exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配exp前面的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;零宽断言&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;=exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配exp后面的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;零宽断言&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?!exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配后面跟的不是exp的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;零宽断言&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?&amp;lt;!exp)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;匹配前面不是exp的位置&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;注释&lt;/td&gt;
&lt;td&gt;&lt;code&gt;(?#comment)&lt;/code&gt;&lt;/td&gt;
&lt;td&gt;用于提供注释让人阅读&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;对于前两个语法，前面都已经解释过了，第三个（&lt;code&gt;(?:exp)&lt;/code&gt;）不会改变正则表达式的处理方式，只是这样的组匹配的内容不会被捕获成组，也不会拥有组号。&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://bbs.csdn.net/topics/120096404&#34;&gt;&amp;ldquo;那么，我为什么要这么做呢？&amp;rdquo;&lt;/a&gt;——好问题，你觉得为什么呢？&lt;/p&gt;

&lt;p&gt;接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西，也就是说它们像&lt;code&gt;\b&lt;/code&gt;、&lt;code&gt;^&lt;/code&gt;、&lt;code&gt;$&lt;/code&gt;那样用于指定一个位置，这个位置应该满足一定的条件(即断言)，因此它们也被称为零宽断言。最好还是拿例子来说明吧：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(?=exp)&lt;/code&gt;也叫零宽度正预测先行断言，它断言自身出现的位置的后面能匹配表达式exp。比如&lt;code&gt;\b\w+(?=ing\b)&lt;/code&gt;，匹配以ing结尾的单词的前面部分(除了ing以外的部分)，如查找I&amp;rsquo;m singing while you&amp;rsquo;re dancing.时，它会匹配sing和danc。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;(?&amp;lt;=exp)&lt;/code&gt;也叫零宽度正回顾后发断言，它断言自身出现的位置的前面能匹配表达式exp。比如&lt;code&gt;(?&amp;lt;=\bre)\w+\b&lt;/code&gt;会匹配以re开头的单词的后半部分(除了re以外的部分)，例如在查找reading a book时，它匹配ading。&lt;/p&gt;

&lt;p&gt;同理，&lt;code&gt;(?!exp)&lt;/code&gt;也叫零宽度负预测先行断言，它断言自身出现的位置的后面能不匹配表达式exp。例如：&lt;code&gt;\d{3}(?!\d)&lt;/code&gt;匹配三位数字，而且这三位数字的后面不能是数字；&lt;code&gt;\b((?!abc)\w)+\b&lt;/code&gt;匹配不包含连续字符串abc的单词。&lt;/p&gt;

&lt;p&gt;同理，&lt;code&gt;(?&amp;lt;!exp)&lt;/code&gt;也叫零宽度负回顾后发断言，它断言此位置的前面不能匹配表达式exp：(?&amp;lt;![a-z])\d{7}匹配前面不是小写字母的七位数字。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;问题6：如何匹配一个不包含属性的简单HTML标签内里的内容？&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;唉，先别急着走啊，不用慌张，我们一点点来做。首先一个HTML标签是什么样子的？你告诉我，是类似&lt;code&gt;&amp;lt;div&amp;gt;abc&amp;lt;/div&amp;gt;&lt;/code&gt;这样的，我们要拿到的就是里面的abc。我们再分析一下，有几个条件，首先前面是一个&lt;code&gt;&amp;lt;div&amp;gt;&lt;/code&gt;，后面跟着&lt;code&gt;&amp;lt;/div&amp;gt;&lt;/code&gt;，&lt;code&gt;div&lt;/code&gt;的部分是一样的，这里可以用分组。
然后，我们先将前后两个部分写出来——&lt;code&gt;(?&amp;lt;=&amp;lt;\w+&amp;gt;)&lt;/code&gt;和&lt;code&gt;(?=&amp;lt;\/\w+&amp;gt;)&lt;/code&gt;，我们再引入分组的概念，得到&lt;code&gt;(?&amp;lt;=&amp;lt;\w+&amp;gt;)&lt;/code&gt;和&lt;code&gt;(?=&amp;lt;\/\1&amp;gt;)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;那么现在，只需要将标签和内容组合起来：&lt;code&gt;(?&amp;lt;=&amp;lt;\w+&amp;gt;).*(?=&amp;lt;\/\1&amp;gt;)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;如果一下子没看懂也没关系，不要着急，仔细理一下。&lt;/p&gt;

&lt;p&gt;小括号的另一种用途是通过语法&lt;code&gt;(?#comment)&lt;/code&gt;来包含注释。例如：
&lt;code&gt;
       (?&amp;lt;=    # 断言要匹配的文本的前缀
       &amp;lt;(\w+)&amp;gt; # 查找尖括号括起来的字母或数字(即HTML/XML标签)
       )       # 前缀结束
       .*      # 匹配任意文本
       (?=     # 断言要匹配的文本的后缀
       &amp;lt;\/\1&amp;gt;  # 查找尖括号括起来的内容：前面是一个&amp;quot;/&amp;quot;，后面是先前捕获的标签
       )       # 后缀结束
&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;补充&#34;&gt;补充&lt;/h3&gt;

&lt;p&gt;如果你看到了这里，恭喜你，你已经完成了正则表达式的修炼！你已经可以带着你学到的知识，去其他人面前露一手了。先别急着走，我这还有几句话要补充。&lt;/p&gt;

&lt;p&gt;当正则表达式中包含能接受重复的限定符时，通常的行为是（在使整个表达式能得到匹配的前提下）匹配尽可能多的字符。以这个表达式为例：&lt;code&gt;a.*b&lt;/code&gt;，它将会匹配最长的以a开始，以b结束的字符串。如果用它来搜索aabab的话，它会匹配整个字符串aabab。这被称为贪婪匹配。&lt;/p&gt;

&lt;p&gt;有时，我们更需要懒惰匹配，也就是匹配尽可能少的字符。前面给出的限定符都可以被转化为懒惰匹配模式，只要在它后面加上一个问号&lt;code&gt;?&lt;/code&gt;。这样&lt;code&gt;.*?&lt;/code&gt;就意味着匹配任意数量的重复，但是在能使整个匹配成功的前提下使用最少的重复。现在看看懒惰版的例子吧：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;a.*?b&lt;/code&gt;就会去匹配最少的字符串，以a开始，以b结束的字符串。如果把它应用于aabab的话，它会匹配aab（因为它是从左往右匹配，得到第一个符合规则的就不会继续匹配了)。这里再补充一个懒惰限定符：&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&#34;center&#34;&gt;代码/语法&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;*?&lt;/td&gt;
&lt;td&gt;重复零次或更多次，但尽可能少重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;+？&lt;/td&gt;
&lt;td&gt;重复一次或更多次，但尽可能少重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;？？&lt;/td&gt;
&lt;td&gt;重复零次或一次，但尽可能少重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,}&lt;/td&gt;
&lt;td&gt;重复n次或更多次，但尽可能少重复&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td align=&#34;center&#34;&gt;{n,m}？&lt;/td&gt;
&lt;td&gt;重复n到m次，但尽可能少重复&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;好了，在完成了本文的同时，我也算是初步完成了正则的修炼，我要去露一手了：)&lt;/p&gt;

&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.runoob.com/regexp/regexp-syntax.html&#34;&gt;正则表达式 – 语法 | 菜鸟教程&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://deerchao.net/tutorials/regex/regex.htm&#34;&gt;正则表达式30分钟入门教程&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>即插即用的缓动小算法</title>
      <link>https://luolr.github.io/post/easeout-algorithm/</link>
      <pubDate>Sat, 20 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luolr.github.io/post/easeout-algorithm/</guid>
      <description>&lt;p&gt;前端们在日常开发中，总免不了要跟一些动画效果打交道，为了实现这个动画效果，要么写一段干巴巴、效果也不怎么好的代码，，要么直接就是拿来主义。我不是说这种做法不好，因为我也是这么做的:)
不过后来我发现这些拿来就用的库中，有些只是使用一些较为简单的算法，自己就可以轻松的实现，本文即将介绍的算法——即插即用的缓动小算法。
&lt;/p&gt;

&lt;h3 id=&#34;原理&#34;&gt;原理&lt;/h3&gt;

&lt;p&gt;假设要从数值A变化到数值B，如果是线性运动，则每次移动距离是一样；如果是缓动，每次移动距离不一样。那如何才能不一样呢？很简单，按比例移动就可以。&lt;/p&gt;

&lt;p&gt;例如：每次移动剩余距离的一半。&lt;/p&gt;

&lt;p&gt;对吧，超容易理解的。&lt;/p&gt;

&lt;p&gt;比方说：你是一只猴子，距离你64的地方有一棵香蕉树，你马上向你心爱的香蕉树跑去，不过由于体力的原因，每次只能移动（剩余）一半的距离，则，你们之间的距离下一秒就是32,再下一秒就是16，然后8，然后4，然后2，然后1，然后……你就可以吃到香蕉了，这个过程就是一个典型的先快后慢的缓动运动过程。&lt;/p&gt;

&lt;p&gt;用一个简单的公式表示就是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;A = A + (B - A) / 2&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;翻译一下就是：&lt;/p&gt;

&lt;p&gt;&lt;code&gt;我下一秒的位置 = 现在位置 + 现在和香蕉树之间距离的一半&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;实现&#34;&gt;实现&lt;/h3&gt;

&lt;p&gt;在知道原理之后，就可以开始动手实现了，&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;// 滚动到顶部缓动实现
// rate表示缓动速率，默认是2

var backToTop = function (rate) {
    var doc = document.body.scrollTop? document.body : document.documentElement;
    var scrollTop = doc.scrollTop;

    var top = function () {
        scrollTop = scrollTop + (0 - scrollTop) / (rate || 2);

        // 临界判断，终止动画
        if (scrollTop &amp;lt; 1) {
            doc.scrollTop = 0;
            return;
        }
        doc.scrollTop = scrollTop;
        // 用于绘制动画，不支持的浏览器可以用setTimeout来代替
        requestAnimationFrame(top);    
    };
    top();
};

// requestAnimationFrame的兼容处理
if (!window.requestAnimationFrame) {
    requestAnimationFrame = function(fn) {
        setTimeout(fn, 17);
    };  
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;扩展&#34;&gt;扩展&lt;/h3&gt;

&lt;p&gt;一名优秀的程序猿断不会止步于此，我们可以把这个方法抽取出来。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Window.easeout = function (A, B, rate) {
    if (A == B || typeof A != &#39;number&#39;) {
        return;    
    }
    var doc = document.body.scrollTop? document.body : document.documentElement;
    B = B || 0;
    rate = rate || 2;

    var run = function () {
        A = A + (B - A) / rate;

        if (A &amp;lt; 1) {
            doc.scrollTop = 0;
            return;
        }
        doc.scrollTop = A;
        requestAnimationFrame(run);    
    };
    run();
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;这样就可以全局使用了，是不是很开森？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>前端性能优化：从入门到放弃？</title>
      <link>https://luolr.github.io/post/web-optimization/</link>
      <pubDate>Sat, 01 Apr 2017 00:00:00 +0000</pubDate>
      
      <guid>https://luolr.github.io/post/web-optimization/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;作为一名合格的web开发人员，不应该仅仅满足于功能的实现，前端性能的优化也是我们必须要关注的问题。我们都不希望自己辛辛苦苦写成的代码，却因为优化不到位的问题，带给用户不好的体验。为此，我们可以做不少的事。
&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;对于前端性能优化的讨论，一直都不是一个过时的话题，前有雅虎的&lt;a href=&#34;https://developer.yahoo.com/performance/rules.html&#34;&gt;35条黄金法则&lt;/a&gt;，后有O’Reilly 出版的两本性能优化圣经《高性﻿能网站建设指南》、《高性能网站建设进阶指南》，这些都很值得我们学习，将会是我们在探索性能优化道路上的指路明灯。那么，我们首先来看看雅虎的军规吧，我选取了其中的一部分。&lt;/p&gt;

&lt;h4 id=&#34;雅虎-17-条性能优化原则及其分类&#34;&gt;雅虎 17 条性能优化原则及其分类：&lt;/h4&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;优化方向&lt;/th&gt;
&lt;th&gt;优化手段&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;请求数量&lt;/td&gt;
&lt;td&gt;合并脚本和样式表，CSS Sprites，拆分初始化负载，划分主域&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;请求带宽&lt;/td&gt;
&lt;td&gt;开启 GZip，精简 JavaScript，移除重复脚本，图像优化&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;缓存利用&lt;/td&gt;
&lt;td&gt;使用 CDN，使用外部 JavaScript 和 CSS，添加 Expires 头，减少 DNS 查找，配置 ETag，使 AjaX 可缓存&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;页面结构&lt;/td&gt;
&lt;td&gt;将样式表放在顶部，将脚本放在底部，尽早刷新文档的输出，延迟加载 JavaScript&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;代码校验&lt;/td&gt;
&lt;td&gt;避免 CSS 表达式，避免重定向&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h4 id=&#34;优化原则细则&#34;&gt;优化原则细则：&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;请求数量：

&lt;ul&gt;
&lt;li&gt;合并脚本和样式表：通过将脚本和样式表合并的方式，可以有效的减少http请求的次数，从而减少DNS请求所耗费的时间和对服务器的压力。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;CSS Sprites&lt;/code&gt;：即CSS 雪碧图，通过将众多细小的图片整合成一个文件，从而减少http请求次数。&lt;/li&gt;
&lt;li&gt;拆分初始化负载：对于页面中一开始加载时不需要执行的资源，可以将其分离出来等到需要时再加载。&lt;/li&gt;
&lt;li&gt;划分主域：众所周知，在 HTTP/1.x 协议中「浏览器客户端在同一时间，针对同一域名下的请求有一定数量限制。超过限制数目的请求会被阻塞」，而不同浏览器对该限制的数目也不尽相同，划分主域、配置静态资源专用域，目的就是变相的解决浏览器针对同一域名的请求限制阻塞问题。但不易过多，否则 DNS 的查询时间也是个问题。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;请求宽带：

&lt;ul&gt;
&lt;li&gt;开启&lt;code&gt;GZip&lt;/code&gt;：服务端启用 Gzip 可以有效的减少数据传输量，Gzip 对于基于文本的文件（CSS、JavaScript、HTML）压缩效果最好，所有现代浏览器都支持 Gzip 压缩并将自动请求该压缩
精简JavaScript，移除重复脚本：这个就不必细说了，减少重复的代码，避免无意义的脚本执行。&lt;/li&gt;
&lt;li&gt;图像优化：对于要上传的图片，尽量保证该图片已经是经过压缩优化过的。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;缓存利用：

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;CDN&lt;/code&gt;：利用内容分发网络能够有效的减少资源响应时间，提升用户体验。
使用外部JavaScript和CSS：浏览器可以将外部的 JavaScript 和 CSS 文件进行缓存，而如果将其写成内联样式，嵌入至 HTML 文档里，那么每次请求该文档时它们都会被下载。而且如果多个页面都用到了相同的脚本，那么使用浏览器缓存的外部JavaScript和CSS必然是更好的选择。&lt;/li&gt;
&lt;li&gt;添加 &lt;code&gt;Expires&lt;/code&gt; 头：对于一些不怎么改变的静态资源，可以设置文件头过期时间Expires的值为“Never expire”（永不过期），而对于一些动态的资源，可以使用恰当的Cache-Control文件头来帮助浏览器进行选择性的请求，通过这样的方式，可以有效的利用浏览器的缓存机制来减少HTTP请求的大小和次数以加快页面访问速度。&lt;/li&gt;
&lt;li&gt;减少 &lt;code&gt;DNS&lt;/code&gt; 查找：由于DNS的解析需要花费一定的时间，减少DNS查找次数可以节省响应时间，减少主机名的数量可以减少DNS查找次数。&lt;/li&gt;
&lt;li&gt;配置 &lt;code&gt;ETag&lt;/code&gt;：服务端配置 ETag 是一种有效的 Web 缓存验证机制，并且允许客户端进行缓存协商。这就使得缓存变得更加高效，而且节省带宽。如果资源的内容没有发生改变，服务器就不需要发送一个完整的响应。ETag 也可用于乐观并发控制，作为一种防止资源同步更新而相互覆盖的方法。&lt;/li&gt;
&lt;li&gt;使 AjaX 可缓存：Ajax缓存和HTTP缓存效果相同，可以通过设置Expires、Last-Modified、Cache-Control 等HTTP响应头的方式实现，具体的实现难度偏高。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;页面结构：

&lt;ul&gt;
&lt;li&gt;将样式表放在顶部，将脚本放在底部：Js的下载以及执行会阻塞DOM与CSSOM的下载与构建，因此将样式表放在body的顶部，而将脚本放在底部，用于优先加载html和css。&lt;br&gt;「推荐阅读：&lt;a href=&#34;https://developers.google.com/web/fundamentals/performance/critical-rendering-path/render-tree-construction?hl=zh-cn&#34;&gt;渲染树构建、布局及绘制&lt;/a&gt; 」&lt;/li&gt;
&lt;li&gt;延迟加载 JavaScript：默认情况下，JavaScript 执行会阻塞解析器：当浏览器在文档中遇到一个 script，它必须暂停 DOM 构建，移交控制权给 JavaScript 运行时，让脚本先执行，然后才继续处理 DOM。为了优先构建渲染树，有时候需要编写额外的代码来延迟脚本的执行&lt;br&gt;「推荐阅读：&lt;a href=&#34;http://web.jobbole.com/82317/&#34;&gt;如何延迟加载JS&lt;/a&gt; 」&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;代码校验：

&lt;ul&gt;
&lt;li&gt;避免 CSS 表达式：CSS 表达式是动态设置 CSS 属性的强大（但危险）方法。表达式的问题就在于它的计算频率要比我们想象的多。不仅仅是在页面显示和缩放时，就是在页面滚动、乃至移动鼠标时都会要重新计算一次，可能会对页面的性能产生影响。因此CSS表达式的使用需要慎重。&lt;/li&gt;
&lt;li&gt;避免重定向：当页面发生了重定向，在新的HTMl文档到达之前，当前页面的资源不会被加载，可能呈现空白页面。
&lt;br&gt;
在了解Yahoo军规后，想必对web性能优化有了一个大致的了解。当然，除了军规之外，也有不少其他要注意的细节。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;javascript-优化&#34;&gt;JavaScript 优化&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Dom操作优化&lt;/p&gt;

&lt;p&gt;首先澄清两个概念——Repaint 和 Reflow：Repaint 也叫 Redraw，它指的是一种不会影响当前 DOM 的结构和布局的一种重绘动作。如下动作会产生 Repaint 动作：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;不可见到可见（visibility 样式属性）&lt;/li&gt;
&lt;li&gt;颜色或图片变化（background, border-color, color 样式属性）&lt;/li&gt;
&lt;li&gt;不改变页面元素大小，形状和位置，但改变其外观的变化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Reflow 比起 Repaint 来讲就是一种更加显著的变化了。它主要发生在 DOM 树被操作的时候，任何改变 DOM 的结构和布局都会产生 Reflow。但一个元素的 Reflow 操作发生时，它的所有父元素和子元素都会放生 Reflow，最后 Reflow 必然会导致 Repaint 的产生。举例说明，如下动作会产生 Reflow 动作：
+ 浏览器窗口的变化
+ DOM 节点的添加删除操作
+ 一些改变页面元素大小，形状和位置的操作的触发&lt;/p&gt;

&lt;p&gt;实际上，Reflow 比起 Repaint 会消耗更多的资源，因此，我们应该尽量减少 Reflow 的发生，或者将其转化为只会触发 Repaint 操作的代码。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var tipBox = document.createElement(&#39;div&#39;);
document.body.appendChild(&#39;tipBox&#39;); //reflow
var tip1 = document.createElement(&#39;div&#39;);
var tip2 = document.createElement(&#39;div&#39;);
tipBox.appendChild(tip1); //reflow
tipBox.appendChild(tip2); //reflow  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如上代码会产生三次reflow，优化后的代码如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-javascript&#34;&gt;var tipBox = document.createElement(&#39;div&#39;);
      tip1 = document.createElement(&#39;div&#39;);
      tip2 = document.createElement(&#39;div&#39;);
tipBox.appendChild(tip1);
tipBox.appendChild(tip2);
document.body.appendChild(&#39;tipBox&#39;); //reflow 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;经过优化，只会产生一次reflow，减少了不必要的开销。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;尽量采用点号&lt;/p&gt;

&lt;p&gt;在 JavaScript 中，你可以使用点号 (foo.bar) 或者方括号 (foo[&amp;ldquo;bar&amp;rdquo;])来访问属性。然而，点号通常是首选，因为它更加易读，简洁，也更适于 JavaScript 压缩。&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;减少全局变量的使用&lt;/p&gt;

&lt;p&gt;JavaScript 代码解释执行，在进入函数内部时，它会预先分析当前的变量，并将变量存放在不同的层级中，一般情况下： 局部变量放入最浅的层级 1，全局变量、try - catch等则放入较深的层级 2，并根据嵌套层级依次加深。变量所在的层越浅，访问（读取或修改）速度越快，反之则越。&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;html-优化&#34;&gt;HTML 优化&lt;/h4&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;使用合适的的元素可保证代码的易读性&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;当网站支持HTML5时，使用&lt;code&gt;&amp;lt;header&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;footer&amp;gt;&lt;/code&gt;，&lt;code&gt;&amp;lt;nav&amp;gt;&lt;/code&gt;等语义化标签，可以很清晰的体现出该内容的功能。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;h1&amp;gt;(&amp;lt;h2&amp;gt;,&amp;lt;h3&amp;gt;…)&lt;/code&gt;表示标题，&lt;code&gt;&amp;lt;ul&amp;gt;&lt;/code&gt;或&lt;code&gt;&amp;lt;ol&amp;gt;&lt;/code&gt;实现列表。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;em&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt;标签替代&lt;code&gt;&amp;lt;i&amp;gt;&lt;/code&gt;和&lt;code&gt;&amp;lt;b&amp;gt;&lt;/code&gt;标签。&lt;/li&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;label&amp;gt;&lt;/code&gt;元素，可以增强使用、、用户的使用体验。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;将文本和元素混合，并作为另一元素的子元素，会导致布局错误，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;form-control&amp;quot;&amp;gt;
    Name:&amp;lt;input type=&amp;quot;text&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;换成这样的写法好些：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;div class=&amp;quot;form-control&amp;quot;&amp;gt;
    &amp;lt;label for=&amp;quot;name&amp;quot;&amp;gt;Name:&amp;lt;/label&amp;gt;
    &amp;lt;input type=&amp;quot;text&amp;quot; id=&amp;quot;name&amp;quot;&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;避免不合理的布局&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;使用&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;元素修饰文本，而不是布局；默认&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt;是自动提供边缘，而且其他样式也是浏览器默认提供的。&lt;/li&gt;
&lt;li&gt;避免使用&lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt;分行，可以使用&lt;code&gt;block&lt;/code&gt;元素或CSS显示属性来代替。&lt;/li&gt;
&lt;li&gt;避免使用&lt;code&gt;&amp;lt;hr&amp;gt;&lt;/code&gt;来添加水平线，可使用CSS的border-bottom 来代替。&lt;/li&gt;
&lt;li&gt;尽可能的避免滥用&lt;code&gt;div&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;尽量少用Tables来布局。&lt;/li&gt;
&lt;li&gt;可以多多使用Flex Box。&lt;/li&gt;
&lt;li&gt;内联元素中不可嵌套块级元素。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;css-优化&#34;&gt;CSS 优化&lt;/h4&gt;

&lt;p&gt;一般来说，页面渲染所需的时间将取决于文档大小、应用的样式，以及运行文档的设备：文档越大，浏览器需要完成的工作就越多；样式越复杂，绘制需要的时间就越长。虽然现在各大浏览器的渲染引擎经过无数版本的优化，都已经十分强大，CSS对于页面渲染的性能影响基本已经很小。不过，不放弃任何可能的优化，不正是是我们广大程序员的一大优点嘛。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;对CSS进行合并、压缩&lt;/li&gt;
&lt;li&gt;不使用CSS表达式&lt;/li&gt;
&lt;li&gt;移除空的CSS规则&lt;/li&gt;
&lt;li&gt;不滥用Float&lt;/li&gt;
&lt;li&gt;不声明过多的Font-size&lt;/li&gt;
&lt;li&gt;值为0时不需要任何单位&lt;/li&gt;
&lt;li&gt;选用合适的CSS选择器：
对于CSS选择器的使用建议遵循以下原则：使用时能具体则具体，不过要注意避免层级过深，对于一些相似的样式可以将其中相同的部分抽取出来单独作为一个样式。附上css选择符开销排序：&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;ID选择符 #box
类选择符 .box
类型选择符 div
相邻兄弟选择符 h4 + #pics
子选择符 #pics li
后代选择符 .box a{}
通配选择符 *
属性选择符 [href=”#pic”]
伪类和伪元素 a:hover
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;其他优化&#34;&gt;其他优化&lt;/h4&gt;

&lt;p&gt;除了以上优化之外，许多大公司（例如腾讯）会选择对网络以及服务器端进行优化，感兴趣的同学可以Google相关资料。&lt;br&gt;
「推荐阅读：&lt;a href=&#34;http://velocity.oreilly.com.cn/2013/ppts/16_ms_optimization--web_front-end_performance_optimization.pdf&#34;&gt;16毫秒的优化&lt;/a&gt; 」&lt;/p&gt;

&lt;h4 id=&#34;参考资料&#34;&gt;参考资料&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://fex.baidu.com/blog/2014/03/fis-optimize/&#34;&gt;前端工程与性能优化&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://isux.tencent.com/h5-performance.html&#34;&gt;移动H5前端性能优化指南&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.imooc.com/article/4307&#34;&gt;你不可不知的HTML优化技巧&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>